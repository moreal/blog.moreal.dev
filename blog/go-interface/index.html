<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <link rel="shortcut icon" href="logo.svg"><title>How Go interface works | </title>
  <meta name="title" content="How Go interface works">
<meta name="description" content="">
<meta name="referrer" content="strict-origin-when-cross-origin">
  <style>
    :root {
    --width: 800px;
    --font-main: Verdana, sans-serif;
    --font-secondary: Verdana, sans-serif;
    --font-scale: 1em;
    --background-color: #fff;
    --heading-color: #222;
    --text-color: #444;
    --link-color: #3273dc;
    --visited-color: #8b6fcb;
    --code-background-color: #f2f2f2;
    --code-color: #222;
    --blockquote-color: #222;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: #01242e;
      --heading-color: #eee;
      --text-color: #ddd;
      --link-color: #8cc2dd;
      --visited-color: #8b6fcb;
      --code-background-color: #000;
      --code-color: #ddd;
      --blockquote-color: #ccc;
    }
  }

  body {
    font-family: var(--font-secondary);
    font-size: var(--font-scale);
    margin: auto;
    padding: 20px;
    max-width: var(--width);
    text-align: left;
    background-color: var(--background-color);
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: var(--text-color);
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: var(--font-main);
    color: var(--heading-color);
  }

  a {
    color: var(--link-color);
    cursor: pointer;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  nav a {
    margin-right: 8px;
  }

  nav span.active {
    font-weight: bold;
    margin-right: 10px;
  }
  strong,
  b {
    color: var(--heading-color);
  }

  button {
    margin: 0;
    cursor: pointer;
  }

  main {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  hr {
    border: 0;
    border-top: 1px dashed;
  }

  img {
    max-width: 100%;
  }

  pre code {
    background-color: var(--code-background-color);
    color: var(--code-color);
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 0.875rem;
    overflow-x: auto;
  }

  code {
    font-family: monospace;
    padding: 2px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
  }

  blockquote {
    border-left: 1px solid #999;
    color: var(--code-color);
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px 0;
    text-align: center;
  }

  .title:hover {
    text-decoration: none;
  }

  .title h1 {
    font-size: 1.5em;
  }

  .inline {
    width: auto !important;
  }

  .highlight,
  .code {
    padding: 1px 15px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
    margin-block-start: 1em;
    margin-block-end: 1em;
    overflow-x: auto;
  }

  /* blog post list */
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: var(--visited-color);
  }

  .tags {
    font-size: smaller;
  }

  </style><style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap');
@import url('https://unpkg.com/@catppuccin/palette/css/catppuccin.css');

main {
  font-family: "Noto Serif CJK KR", "Noto Serif KR", serif;
  font-optical-sizing: auto;
  font-style: sans-serif;
  font-feature-settings: "chws", "halt"
}

  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: var(--ctp-macchiato-base);
      --heading-color: var(--ctp-macchiato-text);
      --text-color: var(--ctp-macchiato-subtext1);
      --link-color: var(--ctp-macchiato-sky);
      --visited-color: var(--ctp-macchiato-mauve);
      --code-background-color: var(--ctp-macchiato-crust);
      --code-color: var(--ctp-macchiato-text);
      --blockquote-color: var(--ctp-macchiato-overlay2);
     }
  }
</style>

</head>
<body>
  <header>
  <a href="https://moreal.dev/" class="title">
    <h1></h1>
  </a>
  <nav aria-label="moreal dev">
      <a href="https://moreal.dev/">home</a>
      <a href="https://moreal.dev/blog/">blog</a>
      <a href="https:&#x2F;&#x2F;resume.moreal.dev&#x2F;">resume</a>
  </nav>
</header>
<h1>How Go interface works</h1>
      <p>
        <i>
          <time datetime="2020-02-22T00:00:00+00:00" pubdate>22 Feb, 2020</time>
        </i>
      </p>
  <main>
    <h2 id="yimun">의문</h2>
<p><code>utilForever/falcon</code>의 간단한 프로토타입을 만들면서 <code>CompilerProxy</code> 인터페이스를 구현하는 <code>GccCompilerProxy</code> 구조체를 작성하였습니다.</p>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#65737e;">// compiler_proxy_test.go
</span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">compilerProxy </span><span>*</span><span style="color:#b48ead;">CompilerProxy </span><span>= </span><span style="color:#bf616a;">NewGccCompilerProxy</span><span>()
</span><span>
</span><span style="color:#65737e;">// compiler_proxy.go
</span><span style="color:#b48ead;">type </span><span>CompilerProxy </span><span style="color:#b48ead;">interface </span><span>{
</span><span>	</span><span style="color:#8fa1b3;">AddLibrary</span><span>()
</span><span>	</span><span style="color:#8fa1b3;">IncludeDirectory</span><span>()
</span><span>	</span><span style="color:#8fa1b3;">Compile</span><span>(</span><span style="color:#bf616a;">srcPath</span><span>, </span><span style="color:#bf616a;">outPath </span><span style="color:#b48ead;">string</span><span>)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">type </span><span>GccCompilerProxy </span><span style="color:#b48ead;">struct </span><span>{}
</span><span>
</span><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">cp </span><span>*</span><span style="color:#b48ead;">GccCompilerProxy</span><span>) </span><span style="color:#8fa1b3;">AddLibrary</span><span>() {}
</span><span>
</span><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">cp </span><span>*</span><span style="color:#b48ead;">GccCompilerProxy</span><span>) </span><span style="color:#8fa1b3;">IncludeDirectory</span><span>() {}
</span><span>
</span><span style="color:#b48ead;">func </span><span>(</span><span style="color:#bf616a;">cp </span><span>*</span><span style="color:#b48ead;">GccCompilerProxy</span><span>) </span><span style="color:#8fa1b3;">Compile</span><span>(</span><span style="color:#bf616a;">srcPath</span><span>, </span><span style="color:#bf616a;">outPath </span><span style="color:#b48ead;">string</span><span>) {}
</span><span>
</span><span style="color:#b48ead;">func </span><span style="color:#8fa1b3;">NewGccCompilerProxy</span><span>() *</span><span style="color:#b48ead;">GccCompilerProxy </span><span>{
</span><span>	</span><span style="color:#b48ead;">return </span><span>&amp;</span><span style="color:#bf616a;">GccCompilerProxy</span><span>{}
</span><span>}
</span></code></pre>
<p>당연히 <em><code>*interface</code> = <code>*struct</code></em> 대입이 될 거라 생각했지만 컴파일러는 제게 에러 메시지 만을 남겼습니다.</p>
<blockquote>
<p>Cannot use 'NewGccCompilerProxy()' (type *GccCompilerProxy) as type *CompilerProxy in assignment</p>
</blockquote>
<p>저 컴파일 에러 메시지를 보고서 생각에 빠졌습니다. C#에서도 <code>ref</code> 키워드를 이용할 때 <code>interface</code>와 <code>class</code> 두 타입 앞에 모두 붙였었는데 Go 에서는 뭔가 어떻게 다른 걸까라는 생각과 함께 <code>interface</code> 라는 키워드가 있는 여러 언어를 접해 보지 못했다는 것도 실감했습니다.</p>
<p><a href="https://tour.golang.org/">A Tour of Go</a> 와 Go 언어로 작성된 여러 코드들을 살펴보다가 <code>interface{}</code> 와 같이 사용하는 것을 보았습니다. 그 타입은 모든 타입과 매치되고 마치 <code>Object</code> 타입 처럼 보였다. 실제로 Go는 <a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">Reflection</a>도 지원합니다. 그렇다면 Go 는 <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>나 <a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)">C#</a> 처럼 VM위에서 돌아가는 걸까 라는 생각도 들었지만 <a href="https://golang.org/doc/faq#runtime">FAQ</a>를 읽어보면 그렇지는 않다고 말하고 있었습니다.</p>
<p>결국 Go 안에서 <code>interface</code> 관련 작업이 어떻게 이루어지는 알아보기로 했고 이 글을 통해 정리해보고자 합니다.</p>
<h2 id="interface-in-go">Interface in Go</h2>
<p>Go Spec 레퍼런스를 보면 <em>인터페이스는 메소드의 집합이다</em> 라고 말하고 있습니다. 자바나 기타 언어에서 와는 다르게 느껴집니다. 이는 <a href="https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)">위키피디아 Protocol(OOP)</a> 문서에서도 말하듯 타언어에서는 명시적으로 인터페이스를 구현해야 한다에 가깝지만, Go에서는 인터페이스의 부분 집합인지를 검사하는 것에 가깝습니다. 인터페이스 검사에서 [Duck Typing] 방식을 채용하고 있기 때문입니다. 정적언어인 Go에서 이것이 어떻게 가능한 것일까요? Go 인터페이스가 어떻게 생겼고, 어떻게 다루지를 안다 면 쉽게 이해할 수 있습니다.</p>
<h2 id="go-interface-gujoce-itab-mandeuneun-beob">Go Interface 구조체 (itab, 만드는 법)</h2>
<p>Go에서 인터페이스는 <code>iface</code>라는 이름의 구조체입니다. 타입을 설명하는 <code>itab</code>의 포인터와 실제 데이터를 가리키는 포인터로 이루어져 있습니다.</p>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#b48ead;">type </span><span>iface </span><span style="color:#b48ead;">struct </span><span>{
</span><span>	</span><span style="color:#bf616a;">tab  </span><span>*</span><span style="color:#b48ead;">itab
</span><span>	</span><span style="color:#bf616a;">data unsafe</span><span>.</span><span style="color:#b48ead;">Pointer
</span><span>}
</span></code></pre>
<p><code>itab</code>은 해당 데이터가 어떤 인터페이스 타입이고 어떤 타입인지, 그리고 함수 테이블을 가지고 있습니다.</p>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#65737e;">// layout of Itab known to compilers
</span><span style="color:#65737e;">// allocated in non-garbage-collected memory
</span><span style="color:#65737e;">// Needs to be in sync with
</span><span style="color:#65737e;">// ../cmd/compile/internal/gc/reflect.go:/^func.dumptabs.
</span><span style="color:#b48ead;">type </span><span>itab </span><span style="color:#b48ead;">struct </span><span>{
</span><span>	</span><span style="color:#bf616a;">inter </span><span>*</span><span style="color:#b48ead;">interfacetype
</span><span>	</span><span style="color:#bf616a;">_type </span><span>*</span><span style="color:#b48ead;">_type
</span><span>	</span><span style="color:#bf616a;">hash  </span><span style="color:#b48ead;">uint32 </span><span style="color:#65737e;">// copy of _type.hash. Used for type switches.
</span><span>	</span><span style="color:#bf616a;">_     </span><span>[</span><span style="color:#d08770;">4</span><span>]</span><span style="color:#b48ead;">byte
</span><span>	</span><span style="color:#bf616a;">fun   </span><span>[</span><span style="color:#d08770;">1</span><span>]</span><span style="color:#b48ead;">uintptr </span><span style="color:#65737e;">// variable sized. fun[0]==0 means _type does not implement inter.
</span><span>}
</span></code></pre>
<p>주석에서 볼 수 있듯이 코드 상에서 정적인 인터페이스 캐스팅이 있을 때 마다 <code>gc/subr.go#implements()</code> 메소드를 호출하여 캐스팅이 가능한지 검사를 합니다. 동시에 <code>itab</code> 을 생성 및 테이블에 등록합니다. 이 <code>itabTable</code>은 <em>.rodata</em> 섹션에 기록하고 실제 프로그램 실행되기 전에 가져오게 됩니다. 이와 관련된 초기화, 컴파일 과정은 다른 글에서 다뤄보도록 하겠습니다.</p>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#b48ead;">func </span><span style="color:#8fa1b3;">implements</span><span>(</span><span style="color:#bf616a;">t</span><span>, </span><span style="color:#bf616a;">iface </span><span>*</span><span style="color:#bf616a;">types</span><span>.</span><span style="color:#b48ead;">Type</span><span>, </span><span style="color:#bf616a;">m</span><span>, </span><span style="color:#bf616a;">samename </span><span>**</span><span style="color:#bf616a;">types</span><span>.</span><span style="color:#b48ead;">Field</span><span>, </span><span style="color:#bf616a;">ptr </span><span>*</span><span style="color:#b48ead;">int</span><span>) </span><span style="color:#b48ead;">bool </span><span>{
</span><span>	</span><span style="color:#65737e;">// *** codes ***
</span><span>	</span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">isdirectiface</span><span>(</span><span style="color:#bf616a;">t0</span><span>) &amp;&amp; !</span><span style="color:#bf616a;">iface</span><span>.</span><span style="color:#bf616a;">IsEmptyInterface</span><span>() {
</span><span>		</span><span style="color:#bf616a;">itabname</span><span>(</span><span style="color:#bf616a;">t0</span><span>, </span><span style="color:#bf616a;">iface</span><span>)
</span><span>	}
</span><span>	</span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true
</span><span>}
</span></code></pre>
<p>위에서 볼 수 있듯이 비어있는 인터페이스, 즉 <code>interface{}</code>로의 변환은 <code>itab</code>을 생성하지 않습니다. 왜냐하면 <code>interface{}</code>의 경우 메소드를 가지지 않는 빈 인터페이스 이므ㅏ로 실제 데이터의 타입과 그 데이터를 가리키는 포인터만 가지고 있으면 충분합니다. 그래서 <code>eface</code>라는 구조체를 사용합니다.</p>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#65737e;">// runtime/runtime2.go
</span><span style="color:#b48ead;">type </span><span>eface </span><span style="color:#b48ead;">struct </span><span>{
</span><span>	</span><span style="color:#bf616a;">_type </span><span>*</span><span style="color:#b48ead;">_type
</span><span>	</span><span style="color:#bf616a;">data  unsafe</span><span>.</span><span style="color:#b48ead;">Pointer
</span><span>}
</span></code></pre>
<p>변환할때는 런타임시에 <code>runtime.convT64</code>, <code>runtime.assertE2I</code> 와 같은 <em>runtime/runtime2.go</em>에 작성되어 있는 함수들을 사용합니다. 어떤 함수들을 호출하게 바뀌는 지는 컴파일 과정중 만드는 SSA를 보면 쉽게 알 수 있습니다.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>$ GOSSAFUNC=func go build test.go
</span><span># command-line-arguments
</span><span>dumped SSA to ./ssa.html
</span></code></pre>
<p><img src="https://user-images.githubusercontent.com/26626194/76146532-dc173e00-60d6-11ea-973a-e5567378e15a.png" alt="image" /></p>
<h2 id="inteopeiseu-mesodeu-hocul">인터페이스 메소드 호출</h2>
<p>인터페이스에서 메소드를 호출 하는 것은 <code>itab</code> 구조체의 필드 <code>fun</code> 가상 테이블에서 함수 포인터를 가져와서 실행합니다. 이 때문에 어쩔 수 없이 성능 저하가 발생합니다. 하지만 CPU 캐시 히트를 맞히면 직접 호출과 다르지 않은 속도를 기대할 수도 있습니다. 이 부분은 <a href="https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md">다음 글</a>에서 잘 설명되어 있기 때문에 생략하겠습니다.</p>
<h2 id="mamuri">마무리</h2>
<p>Golang에서 vm 없이 동적 타입을 어떻게 다루는지, interface가 어떻게 생겼는지, 컴파일러 과정 및 컴파일러 내부 코드 구조를 알 수 있어서 좋았습니다. 앞으로 go로 작성할 때 성능을 신경써야 하는 부분이 있다면 이런 캐시히트도 봐야겠구나 라는 생각이 들었습니다.</p>
<h2 id="reference">Reference</h2>
<ul>
<li>https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</li>
<li>https://research.swtch.com/interfaces</li>
<li>http://www.programmersought.com/article/16341600537/</li>
<li>https://eli.thegreenplace.net/2019/go-compiler-internals-adding-a-new-statement-to-go-part-1/</li>
</ul>

  </main>
  <p>
        Tags:
          <a href="https://moreal.dev/tags/go/">#Go</a>
          <a href="https://moreal.dev/tags/internals/">#Internals</a>
  </p>
<footer>
</footer>
</body>
</html>
