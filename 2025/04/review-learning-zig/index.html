<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    Zig 공부 회고 — 잡다한 블로그
  </title>
  <link rel="stylesheet" href="/static/style.css">
  <link rel="shortcut icon" href="/static/logo.svg" type="image/svg+xml">
  <meta name="description" content="블로그 포스트">
  <meta name="author" content="Moreal (Lee Dogeon)" />
  <meta name="fediverse:creator" content="moreal@hackers.pub" />
  <link rel="me" href="https://social.silicon.moe/@moreal" />
  <link rel="me" href="https://hackers.pub/@moreal" />
</head>

<body class="post">
  
  <header class="post-header">
    <time datetime="2025-04-28T15:00:00.000Z" class="publish-date">
      2025년 4월 28일
    </time>
  </header>
  

  <main>
    <article>
      <h1>Zig 공부 회고</h1>
<h2>글을 시작하기 전에</h2>
<p>이 글은 Zig를 경험한지 4일 정도된 상태에서 과정 및 감상을 기록하기 위해 적은
글입니다. 때문에 Zig를 제대로 이해하지 못하고 적은 글이라고 생각하셔도
무방합니다.</p>
<p>사용하지 않던 새로운 언어라 어색한 것이고, 아직 잘 모르는 것이지 잘못되었다고
생각하지 않습니다. 이 글에 그런 어감으로 적은 부분이 남아있다면 제가 표현을
잘못한 것이니 피드백해주신다면 수정하겠습니다. 🙇‍♂️ 그리고 제가 미처 알지 못하고
지난 Zig의 장점이 있다면 알려주시면 감사히 배우겠습니다 🙏</p>
<h2>Zig를 공부하게 된 배경</h2>
<p>최근에 <a href="https://product.kyobobook.co.kr/detail/S000001033071">함께 자라기 책</a>과
<a href="https://agilestory.blog">애자일 이야기 블로그</a>를 읽었고, 나는 어떻게
학습하는지를 돌아보고 교정해보고 싶었습니다. (관련 글:
<a href="https://agilestory.blog/5664879">프로그래밍 언어 배우기의 달인</a>) 과정을
기록하는 방법으로 노트가 생각이 나서 노트에 시각과 의문이 드는 점들을 기록하며
공부했고, 마무리하며 이 글도 적고 있습니다.</p>
<p>프로그래밍 언어 중 Zig를 선택한 이유는 두 가지인데요:</p>
<ol>
<li>
<p>최근에 Bun이나 CyberScript 등으로 Zig가 자주 언급되었습니다. 또한 Zig
홈페이지의 코드를 볼 때 Rust와 비슷하다는 생각에 비교적 쉽게 공부할 수 있을
것이라 예상했습니다(결과적으로는 그렇지 않았지만요).</p>
</li>
<li>
<p>다른 언어를 공부하면 멘탈 모델을 좀 더 키울 수 있지 않을까 하는 생각이
있었습니다. 그런 흐름에서 최근에 OCaml 같은 언어도 살펴봤었습니다.</p>
</li>
</ol>
<p>언어를 익히면서 프로그램을 직접 구현해보면 이해하는 데 도움이 된다고 느끼는데,
새로운 언어이니만큼 익숙한 프로그램을 구현하면 좋겠다고 생각했습니다. 그래서
이전에 C#, Rust로 구현해봤던 Bencodex를 Zig로 구현하기로 했습니다.</p>
<h2>Zig를 공부한 과정</h2>
<p>처음 <a href="https://ziglang.org/">Zig 홈페이지</a>에 있는 예시 코드를 볼 때 표준
라이브러리 요소를 제외하면 대체로 이해할 수 있을 것 같았습니다. 그래서 우선
기본적인 구현은 GitHub Copilot에게 맡겨보았고, 모르는 문법이나 표준 라이브러리
요소가 나오면 그 부분부터 이해하기로 했습니다.</p>
<p>그러다 언어의 기능을 너무 이해 안하고 넘어갔다는 생각이 들어
<a href="https://codeberg.org/ziglings/exercises/#ziglings">Ziglings</a> 문제들을
풀었습니다. 이를 통해 코드가 좀 더 눈에 들어오게 되었습니다.</p>
<p>하지만 다른 언어에는 있는 기능이 없어서 여전히 어색했습니다. 책에서 봤던 대로
표준 라이브러리 소스코드를 읽어보면서 &quot;이런 패턴은 Zig로는 이렇게
구현하는구나&quot;를 습득하는 데 도움이 되었습니다.</p>
<p>마지막으로 모듈화를 공부하는 데는 <a href="https://zigistry.dev">Zigistry</a>에 있는
라이브러리들을 참조했습니다. 이 과정에서 <code>build.zig</code> 파일을 좀 더 잘 이해하게
되었습니다.</p>
<h2>Zig를 공부하며 인상 깊었던 포인트</h2>
<h3>웹 어셈블리</h3>
<p>Zig를 웹 어셈블리로 빌드하여 사용하는 게 의외로 간단하여 좋았습니다. 아래처럼
명령어를 실행하면 <code>*.wasm</code> 파일이 생성되고 Deno 같은 환경에서는
<code>import {} from &quot;foo.wasm&quot;</code> 같이 간편히 불러올 수 있었습니다.</p>
<pre><code>zig build-exe -target wasm32-freestanding -fno-entry -rdynamic -ofmt=wasm src/root.zig
</code></pre>
<p><a href="https://github.com/chung-leong/zigar">https://github.com/chung-leong/zigar</a> 처럼 이를 보다 편하게 하는 프로젝트도
있었습니다.</p>
<h3>타입 선언 방식</h3>
<p>Zig에서는 타입을 선언할 때 특별히 <code>type</code>, <code>typedef</code> 같은 별도의 키워드가
없습니다. <code>const Animal = struct{ name: []const u8 };</code> 같은 방식으로 타입을
선언합니다. 제네릭의 경우 <code>struct(comptime T: type){ value: T }</code> 같은 식으로
선언할 수 있습니다.</p>
<h3>컴파일 타임 연산</h3>
<p>이 기능은 C++에서의
<a href="https://ko.wikipedia.org/wiki/%ED%85%9C%ED%94%8C%EB%A6%BF_%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">템플릿 메타프로그래밍</a>이나
<a href="https://en.cppreference.com/w/cpp/language/constexpr">constexpr</a>과 유사한 기능
같았습니다. 다만 보다 작성하기 쉽게 느껴졌습니다. 컴파일 타입 리플렉션도
제공하고요.</p>
<h3><code>anytype</code></h3>
<p>정적 타입 언어이지만 <code>anytype</code> 타입이 있는 것이 신기했습니다. TypeScript의
<code>any</code>가 떠오르는 개념이었지만, 다행히 타입 검사는 잘 이루어졌습니다. Zig가
타입을 추론하는 원리를 완전히 이해하지는 못했지만, 시작점(예: <code>main</code>)을 기준으로
사용되는 타입들을 검사하는 것으로 보였습니다.</p>
<p>예를 들어 아래와 같은 함수 <code>f</code>가 있다고 할 때, 인자 <code>x</code>로 어떤 것이 주어질지
미리 알 수 없습니다:</p>
<pre><code class="language-zig">fn f(x: anytype) void {
  x.say(&quot;Hello&quot;);
}
</code></pre>
<p>하지만 위와 같이 함수를 작성한 후에는 인자 <code>x</code>는
<code>fn say(self: @This(), arg: []const u8) void</code> 같은 시그니처의 함수를 가진
<code>struct</code>여야 한다는 것을 추론할 수 있습니다.</p>
<p>기존에 다른 언어로 코드를 작성할 때는 함수에 들어오는 타입을 한정하는 방식으로
코드를 작성했었는데, 이 방식은 개인적으로 혼란스러웠습니다.</p>
<h3>인터페이스 문법의 부재</h3>
<p>Java, TypeScript, C# 같은 언어에서는 <code>interface</code> 같은 타입이 있었고, C++에서는
<code>abstract class</code>, Rust에서는 <code>trait</code>이 있어
<code>로그를 받아 계산 결과를 반환하는 함수 &quot;evaluate&quot;를 가진 타입, Evaluator</code> 같은
타입을 정의하여 활용할 수 있었습니다.</p>
<p>그런데 Zig에서는 이런 타입을 정의하는 방법이 없어 보였습니다. 그래서 표준
라이브러리(<code>std</code>)를 읽어보았습니다. Rust의 <code>trait std::io::Write</code> 같은 역할로
<code>std.io.AnyWriter</code>라는 것이 있었는데, 프록시처럼 함수 포인터를 받아 호출해주는
방식으로 하나의 타입으로 여러 구현체를 사용할 수 있게 하였습니다. 메모리 할당을
담당하는 <code>std.mem.Allocator</code>도 같은 방식이었습니다.</p>
<p>&quot;Zig는 이런 부분까지 선택지로 두고 최적화하게끔 하려는 것인가!&quot;라는 생각에
놀라기도 했고, 다르게 생각하면 최신 언어치고는 기능이 부족하다는 생각도
들었습니다.</p>
<h3>생명주기 추적 도구의 부재</h3>
<p>C언어를 주로 사용했었다면 익히기 더 쉬웠을 것 같습니다. vtable 같은 것도 직접
구현하고, 무엇보다 포인터를 직접 다루는 방식이 C언어 코딩을 배울 때와
비슷했습니다. GC가 없고 직접 할당 및 해제를 해줘야 하는 점이 오랜만에 해보니
어색했습니다. Go의 <code>defer</code> 키워드와 비슷한 <code>errdefer</code> 키워드를 도입하여 메모리
해제를 쉽게 도와주려는 모습을 보았지만, 모든 문제를 해결하는 것은 아니었습니다.
테스트에서 제공되는 Allocator를 사용하면 메모리 누수를 탐지할 수 있는 도구가
있어서 도움이 되었습니다.</p>
<p>그래도 Rust의 라이프타임 검사 같은 기능이 있었다면 좋았을 텐데 하는 아쉬움은
남습니다. Zig가 숨겨진 흐름이 없도록 하는 철학(암묵적 함수 호출 방지)을 가지고
있어 자동으로 처리해주는 기능은 아마 추가되지 않을 것 같지만, 그런 것을
검증하려는 시도는 있는 것 같습니다. (<a href="https://github.com/ityonemo/clr">https://github.com/ityonemo/clr</a>)</p>
<p>Bun에서 메모리 누수가 왜 발생하는지도 이해가 가는 부분이었습니다(메모리 해제를
잘 챙기는 것은 어려운 일이니깐요).</p>
<h2>Zig를 공부하는 과정에서 좋았던 점</h2>
<p>Zig에 대한 이야기는 줄이고 공부를 회고하는 시점으로 돌아오겠습니다.</p>
<p>이번에 Zig를 공부할 때는 노트를 펴고 펜으로 필기하며 진행한 것이 좋은
경험이었습니다. 공부를 회고하려면 과정이 남아있어야 하는데, 기억력에
의존하기에는 놓치는 부분이 많을 것 같았기 때문입니다. 지금 이 글을 적는 것도
필기를 기반으로 합니다. 그 외에도 머리에서 생각하는 것을 적으며 정리해볼때
펜으로 쓰는 것이 가장 자유롭고 편하다고 느낍니다.</p>
<p>그리고 표준 라이브러리를 보는 것이 도움이 되었던 것 같습니다. &quot;쓰기&quot;, &quot;읽기&quot;
같은 기본적인 개념만 보아도 이 언어에서는 추상화를 위해서 어떻게 표현하는지가 잘
보였습니다.</p>
<h2>Zig를 공부하는 과정에서 아쉬운 점</h2>
<p>아쉬운 점 중 하나는 원래 생각했던 멘탈 모델을 늘리는 데는 크게 도움을 받지
못했다는 것입니다. 예전을 돌이켜 보면 &quot;아하!&quot; 모먼트였던 것은 타입 기반
프로그래밍을 이해했을 때였습니다. 타입이란 것은 값의 집합이고, 함수에 입력으로
받는 값의 범위를 한정함으로써 더 예측 가능한 코드를 작성하는 것이 타입 검사의
진정한 의미라는 것을 이해했을 때 눈이 뜨인 기분이었습니다.</p>
<p>그런 &quot;아하!&quot; 모먼트를 다시금 느끼고 싶었지만 그러지 못 했습니다.</p>
<p>때문에 학습하고 싶은 것이 무엇인지 확실히 파악해야 매몰비용이 크지 않을 것
같습니다. 그러기 위해서는 학습 목표를 명확히 하는 것이 중요합니다. 제 경우,
언어를 공부할 때 얻고 싶은 것은 타입 기반으로 더 안정적인 프로그램을 작성하는 데
필요한 사고방식을 습득하는 것입니다. 다시 말해, 타입 검사를 더 잘 활용하는 데
도움이 되는 언어인지 파악한 후 공부를 시작해야 할 것입니다. 이를 위해서는 언어
설계의 목표와 같은 설명을 먼저 살펴보는 것이 좋겠습니다.</p>
<h2>앞으로 어떻게 하면 좋을까?</h2>
<p>위 내용들을 요약해서 나열하면 아래와 같습니다.</p>
<ul>
<li>언어의 철학(목표) 문서가 있다면 가정 먼저 읽자.</li>
<li>언어의 표준 라이브러리가 있다면, <code>Write</code>, <code>Read</code> 같은 개념들을 어떻게
추상화하는지 먼저 살펴보자.</li>
<li>노트에 펜으로 글과 그림을 적으며 정리하자.</li>
</ul>
<h2>부록: Zig 관련 글</h2>
<p>공부하면서 발견한 Zig 관련 글들을 나열해놓습니다.</p>
<ul>
<li><a href="https://matklad.github.io/2025/04/19/things-zig-comptime-wont-do.html">https://matklad.github.io/2025/04/19/things-zig-comptime-wont-do.html</a></li>
<li><a href="https://mitchellh.com/zig/sema">https://mitchellh.com/zig/sema</a></li>
</ul>

    </article>
  </main>
</body>

</html>